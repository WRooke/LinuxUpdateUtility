# Source for Linux Kernel Updater

# UI -> PY CONSOLE COMMAND
# Converts QtDesigner .ui file to .py file readable by python
# python -m PyQt5.uic.pyuic -x [FILENAME].ui -o [FILENAME].py

# Image source resource file compile command
# Compiles QtDesigner image resources file to .py file readable by python
# pyrcc5 -o ImageSources_rc.py ImageSources.qrc

# Pyinstaller command
# Used to package source into .exe file
# pyinstaller -w -F -n OEMLinuxUpdateUtility OEMLinuxUpdateUtility.py


import ipaddress
import os
import re
import sys
import time
from threading import Thread

import paramiko  # SSH Package
import serial  # Serial Package
import serial.tools.list_ports
import tftpy  # TFTP package

# GUI package and components
from PyQt5 import QtWidgets, QtGui, QtCore
from PyQt5.QtCore import pyqtSignal, QObject, QThread, Qt
from PyQt5.QtWidgets import QFileDialog, QDialog

from About import Ui_Form as AboutDialog
from GUI import Ui_Dialog
from PopUp import Ui_PopUpDialog
from Progress import Ui_Form as ProgressDialog


# Custom exceptions to assist in error pop-up displays

# Is raised when entered IP address is invalid
class IPException(Exception):
    pass


# Is raised when no directory is entered
class PathException(Exception):
    pass


# Is raised when serial does not receive data within timeout period (timeout period is variable)
class TimeoutException(Exception):
    pass


# Is raised when directory entered does not contain Linux kernel files
class InvalidDir(Exception):
    pass


# Class which defines pop-up dialog, used for success and error messages
# QDialog is base class, Ui_PopUpDialog comes from PopUp.py, autogenerated by PyQt
class PopUpClass(QDialog, Ui_PopUpDialog):
    def __init__(self, parent=None):
        super(PopUpClass, self).__init__(parent)
        super().setupUi(self)

    # Sets window title, text and picture
    # Takes strings window_title and error_mess, boolean success
    # Images are stored in ImageSources.qrc file, which is compiled to ImageSources.py
    def handle_error(self, window_title, error_mess, success):
        self.popuptext.setText(error_mess)
        self.setWindowTitle(window_title)
        if success:
            self.popupimage.setPixmap(QtGui.QPixmap(":/Images/Images/Success.png"))
        else:
            self.popupimage.setPixmap(QtGui.QPixmap(":/Images/Images/Warning.png"))

    # Opens pop-up window
    def opener(self):
        self.show()

    # Hides pop-up window
    def closer(self):
        self.hide()


# Class which defines progress window, displays process progress
# QDialog is base class, ProgressDialog comes from Progress.py, autogenerated by PyQt
class ProgressClass(QDialog, ProgressDialog):
    def __init__(self, parent=None):
        super(ProgressClass, self).__init__(parent)
        super().setupUi(self)
        # Removes menu bar, effectively disallowing closing the progress window during update
        self.setWindowFlags(Qt.CustomizeWindowHint)

    # Opens progress window
    def opener(self):
        self.show()

    # Closes progress window
    def closer(self):
        self.hide()

    # Takes string update_text, emitted from signal showing what stage process is up to,
    # and int update_num, which sets the progress bars fill amount
    def handle_change(self, update_text, update_num):
        self.Status.setText(update_text)
        self.progressBar.setValue(update_num)


# Class which defines "About" window
# QDialog is base class, AboutDialog comes from About.py, autogenerated by PyQt
class AboutClass(QDialog, AboutDialog):
    def __init__(self, parent=None):
        super(AboutClass, self).__init__(parent)
        super().setupUi(self)

    # Closes About Window
    def closer(self):
        self.hide()

    # Shows About Window
    def opener(self):
        self.show()


# Basic timer object, used in checking for serial timeout
class TimerClass(object):

    # Initialise class members, default timeout is 30s
    def __init__(self):
        self.start = 0
        self.current = 0
        self.TimerStarted = False
        self.Timeout = 30

    # Start timer by logging initial time, setting TimerStarted flag to True
    def StartTimer(self):
        self.start = time.time()
        self.TimerStarted = True

    # Stop timer by setting timer start time and current time to zero, setting TimerStarted flag to false
    def StopTimer(self):
        self.TimerStarted = False
        self.start = 0
        self.current = 0

    # Check time elapsed, subtract current time from start time and compare to specified timeout value.
    # Raise TimeoutException if timeout has completed
    def CheckTimer(self):
        self.current = time.time()
        if (self.current - self.start) > self.Timeout:
            self.TimerStarted = False
            raise TimeoutException


# PyQt QThread containing main Kernel Update function and various helper functions associated with it
# Emits signals to change and display error messages and update progress bar with current status of update procedure
class UpdateThread(QThread):

    # PyQt signal definitions

    # Signal to update progress bar status
    # Takes string (to display current stage) and int (to display progress bar percentage)
    loadStatus = pyqtSignal(str, int)

    # Signal to close progress bar
    closeProg = pyqtSignal()

    # Signal to update error/success message window
    # Takes string (to change window title), string (to change error message)
    # and bool (to determine whether to display error or success image)
    errorMessage = pyqtSignal(str, str, bool)

    # Signal to open pop-up success/error window
    loadPopup = pyqtSignal()

    # Signal to open progress bar
    openProg = pyqtSignal()

    # Signal to close pop-up success/error window
    closePopup = pyqtSignal()


    # Class takes strings on init, used to save IP addresses, COM port and Kernel Path for use in thread
    def __init__(self, COMPort, conIP, PCIP, pathEdit, prodMode):
        QThread.__init__(self)
        self.COMPort = COMPort
        self.conIP = conIP
        self.PCIP = PCIP
        self.pathEdit = pathEdit
        self.prodMode = prodMode

    # Function is run on thread start
    def run(self):

        # Attempt to run update process from runUpdate function
        try:

            # Create serial object ser and open serial connection with given COM port and default 115200 baud
            ser = serial.Serial(self.COMPort, 115200, timeout=0.1)

            # Close serial connection to remove errors
            ser.close()

            # Call runUpdate and pass serial object, IP addresses and kernel path
            self.runUpdate(ser, self.conIP, self.PCIP, self.pathEdit, self.prodMode)

            # If no exceptions are raised, emit signal errorMessage to display success image and message
            self.errorMessage.emit("Success", "Kernel loaded successfully\nController IP address is: " + self.conIP,
                                   True)

            # Open error/success pop-up window
            self.loadPopup.emit()

            # Close progress window
            self.closeProg.emit()

            # Exit thread
            self.quit()

        # Begin exception handling

        # If kernel path is empty, close serial connection, display error message and close progress window,
        # then exit thread
        except PathException:
            ser.close()
            self.errorMessage.emit("Error", "Please select a directory", False)
            self.closeProg.emit()
            self.loadPopup.emit()

            self.quit()

        # If serial port cannot be opened, display error message and close progress window,
        # then exit thread
        except serial.SerialException:
            self.errorMessage.emit("Error",
                                   "Cannot open serial port\nPlease ensure no other program is using the serial port\nand that it is connected correctly",
                                   False)
            self.loadPopup.emit()
            self.closeProg.emit()
            self.quit()

        # If SSH cannot connect, close serial connection, display error message and close progress window,
        # then exit thread
        except paramiko.ssh_exception.SSHException:
            ser.close()
            self.errorMessage.emit("Error",
                                   "Cannot connect to controller through SSH\nPlease ensure controller is connected correctly",
                                   False)
            self.loadPopup.emit()
            self.closeProg.emit()
            self.quit()

        # If given path does not contain kernel files, close serial connection,
        # display error message and close progress window, then exit thread
        except InvalidDir:
            ser.close()
            self.errorMessage.emit("Error",
                                   "Directory does not contain Linux Kernel files\nPlease select a new directory",
                                   False)
            self.loadPopup.emit()
            self.closeProg.emit()
            self.quit()

        # If a given IP address is invalid, close serial connection, display error message and close progress window,
        # then exit thread
        except ipaddress.AddressValueError:
            ser.close()
            self.errorMessage.emit("Error", "IP address not valid\nPlease enter a valid IP", False)
            self.loadPopup.emit()
            self.closeProg.emit()
            self.quit()

        # If kernel path is empty, close serial connection, display error message and close progress window,
        # then exit thread
        except TimeoutException:
            ser.close()
            self.errorMessage.emit("Error", "Serial connection lost\nPlease try again", False)
            self.loadPopup.emit()
            self.closeProg.emit()
            self.quit()

    # Function for sending tilde, used to interrupt UBoot from loading kernel
    # Takes serial object and timer object
    def sendTilde(self, serialObject, timer):

        # Define command strings to send
        # Tilde is sent to interrupt boot sequence
        command = '~\n'

        # 'version' is sent as it gives an output to read
        # 'version' was chosen as the command as it does not return anything in linux, only in UBoot
        query = 'version\n'

        # Newline is sent to ensure nothing is in the input buffer
        newline = '\n'

        # Loop until UBoot command screen is registered
        while 1:
            # Send tilde and read output
            serialObject.write(command.encode())
            out = self.readTimeout(serialObject, timer)

            # Send 'version' query and read output
            serialObject.write(query.encode())
            out = self.readTimeout(serialObject, timer)

            # Use regex to find if UBoot command prompt has been reached
            matchPM3004 = re.search('Colibri VFxx*.', out)
            matchPM3003 = re.search('Colibri iMX6*.', out)
            matchPM3005 = re.search('Colibri iMX6ULL*.', out)

            # If the command prompt has been reached, read 10 lines from the serial object
            # send a newline, and read another 10 lines
            # This ensures that both input and output have no remaining data in them
            if matchPM3004 or matchPM3003 or matchPM3005:
                for i in range(10):
                    out = self.readTimeout(serialObject, timer)

                serialObject.write(newline.encode())
                for i in range(10):
                    out = self.readTimeout(serialObject, timer)
                break

    # Command to write string to serial
    # Takes serial object, string to send and timer
    def writeCommand(self, serialObject, string, timer):

        # Write the string
        serialObject.write(string.encode())

        # Read whatever is given back by the serial device
        out = self.readTimeout(serialObject, timer)

        # Wait for 0.2s, avoids commands running into each other
        time.sleep(0.2)

    # Function to check whether nothing has been received over serial for more than the timeout amount
    # Takes serial object and timer
    def readTimeout(self, serialObject, timer):

        # Read from the serial port
        out = serialObject.readline().decode('utf-8', 'ignore')

        # If no data is read, either start the timer or check the timer
        if out == '':
            if timer.TimerStarted:
                timer.CheckTimer()
            else:
                timer.StartTimer()

        # If data is read, stop the timer
        else:
            timer.StopTimer()

        # Return whatever string was read from the serial data
        return out

    # Checks for Linux login prompt
    # Takes serial object and timer
    def loginCheck(self, serialObject, timer):
        # Define newline command
        newline = '\n'

        # Loop until Linux login screen is registered
        while 1:

            # Read from serial and check if 'iecTeso version' has been read
            # 'iecTeso version' was chosen as it always immediately precedes the login prompt,
            # removing the need to poll for the login screen
            out = self.readTimeout(serialObject, timer)
            matchLogin = re.search('.*login.*', out)
            if matchLogin:

                # If the login screen is found, clear input and output by reading 10 lines, sending a newline,
                # and reading another 10 lines
                for i in range(10):
                    out = self.readTimeout(serialObject, timer)

                self.writeCommand(serialObject, newline, timer)
                for i in range(10):
                    out = self.readTimeout(serialObject, timer)
                break

        # Send username and password
        self.writeCommand(serialObject, 'root\n', timer)
        self.writeCommand(serialObject, 'Netsilicon\n', timer)


    # Main kernel update function
    # Takes IP address strings of controller and PC, string of kernel path given to GUI,
    # and serial object defined in run()
    def runUpdate(self, serialObject, conIP, PCIP, kernelPath, prodMode):

        # Check if IP addresses are valid
        test = ipaddress.IPv4Address(conIP)
        test = ipaddress.IPv4Address(PCIP)

        # Replace slashes in kernel path
        # The TFTP server didn't like the standard way
        newpath = kernelPath.replace('/', '\\')

        # Ensure kernel path is not empty
        if kernelPath == "":
            raise PathException

        # Ensure path actually contains all necessary kernel files
        # NOTE: DOES NOT CHECK CONTENTS, ONLY CHECKS IF THEY EXIST

        PM3004Files = (os.path.isfile(os.path.join(newpath, 'ubifs.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_mmc.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_eth.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_blk.img')) and
                       os.path.isfile(os.path.join(newpath, 'u-boot-nand.imx')) and
                       os.path.isfile(os.path.join(newpath, 'configblock.bin')))

        PM3003Files = (os.path.isfile(os.path.join(newpath, 'boot.vfat')) and
                       os.path.isfile(os.path.join(newpath, 'flash_mmc.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_eth.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_blk.img')) and
                       os.path.isfile(os.path.join(newpath, 'mbr.bin')) and
                       os.path.isfile(os.path.join(newpath, 'imx6dl-colibri-eval-v3.dtb')) and
                       os.path.isfile(os.path.join(newpath, 'root.ext3')) and
                       os.path.isfile(os.path.join(newpath, 'root.ext3-0')) and
                       os.path.isfile(os.path.join(newpath, 'root.ext3-1')) and
                       os.path.isfile(os.path.join(newpath, 'u-boot.imx')) and
                       os.path.isfile(os.path.join(newpath, 'uImage')))

        PM3005Files = (os.path.isfile(os.path.join(newpath, 'ubifs.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_eth.img')) and
                       os.path.isfile(os.path.join(newpath, 'flash_blk.img')) and
                       os.path.isfile(os.path.join(newpath, 'imx6ull-colibri-wifi-eval-v3.dtb')) and
                       os.path.isfile(os.path.join(newpath, 'u-boot-nand.imx')) and
                       os.path.isfile(os.path.join(newpath, 'zImage')))

        if PM3003Files or PM3004Files or PM3005Files:
            pass
        else:
            raise InvalidDir

        # Initialise timer
        timer = TimerClass()

        # Start TFTP server using python process and update progress bar
        self.loadStatus.emit("Starting TFTP server", 1)
        tftpObject = ServerClass(newpath)
        tftpProcess = Thread(target=tftpObject.ServerFunc, args=())
        tftpProcess.start()

        # Open COM port and update progress bar
        self.loadStatus.emit("Opening COM Port", 1)
        serialObject.open()

        if prodMode:
            # Prompt user to cycle power to the controller
            self.errorMessage.emit("Input required", "Please cycle power to the controller",
                                   False)

            # Open error/success pop-up window
            self.loadPopup.emit()

        else:
            # Update progress bar and initialise SSH client
            self.loadStatus.emit("Opening SSH connection", 2)
            client = paramiko.SSHClient()

            # If the SSH key is missing, auto-add it
            # This ensures it won't throw an error if the key isn't found
            # (which it never will be, unless this is run on the same controller with the same version of the kernel twice)
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(conIP, username='root', password='Netsilicon')

            # Open an SFTP protocol and copy network interface file to working directory
            # This file will be loaded on again later to return all network settings to what they were before update
            sftp = client.open_sftp()
            sftp.get('/etc/network/interfaces', os.path.join(os.getcwd(), 'interfaces'))

            # Reboot controller by sending 'reboot' over SSH and update progress bar
            self.loadStatus.emit("Rebooting", 3)
            stdin, stdout, stderr = client.exec_command('reboot')

            # Close SSH client, no longer needed
            client.close()

        # Initialise string commands for updating the kernel
        # Found in kernel SRA
        boot = 'boot\n'
        newline = '\n'
        commandList = []
        update6 = "run update\n"
        out = ''
        if PM3004Files or PM3003Files:
            commandList.append("setenv serverip " + PCIP + "\n")
            commandList.append("setenv ipaddr " + conIP + "\n")
            commandList.append("tftpboot ${loadaddr} ${serverip}:flash_eth.img && source ${loadaddr}\n")

        elif PM3005Files:
            commandList.append("setenv soc imx6ull\n")
            commandList.append("saveenv\n")
            commandList.append("setenv serverip " + PCIP + "\n")
            commandList.append("setenv ipaddr " + conIP + "\n")
            commandList.append("tftpboot ${loadaddr} ${serverip}:flash_eth.img && source ${loadaddr}\n")

        # Not sure if these do anything, may remove in later update
        # serialObject.reset_input_buffer()
        # serialObject.reset_output_buffer()
        if prodMode:
            self.loadStatus.emit("Waiting for user input", 2)
        # Send tilde to interrupt boot sequence and access UBoot
        self.sendTilde(serialObject, timer)

        if prodMode:
            self.closePopup.emit()

        self.loadStatus.emit("Sending TFTP update commands", 3)

        # Send TFTP update commands
        for updateString in commandList:
            self.writeCommand(serialObject, updateString, timer)

        # Send 'run setupdate' command and wait for 'enter run update prompt'
        # This is done differently to the previous commands as it doesn't process instantly
        # When 'enter run update' is found, send 'run update' command
        # serialObject.write(update5.encode())
        while 1:
            out = self.readTimeout(serialObject, timer)
            matchUpdate = re.search('enter "run update"*.', out)
            if matchUpdate:
                serialObject.write(update6.encode())
                break

        # Update progress bar
        self.loadStatus.emit("Downloading over TFTP", 4)

        # Wait for 'resetting' to be received, then send tilde to interrupt reset
        while 1:
            out = self.readTimeout(serialObject, timer)
            matchReset = re.search('resetting*.', out)
            if matchReset:
                self.sendTilde(serialObject, timer)
                break

        # Update progress bar
        self.loadStatus.emit("Rebooting", 5)

        # Write 2 newlines to clear input, send boot command
        self.writeCommand(serialObject, newline, timer)
        self.writeCommand(serialObject, newline, timer)
        self.writeCommand(serialObject, boot, timer)


        # Set timer timeout to 60s
        # This is done to ensure program doesn't end prematurely when PLC is generating SSH keys, which can take >30s
        timer.Timeout = 60

        # Check for login prompt
        self.loginCheck(serialObject, timer)

        # Update progress bar and revert timeout to default value
        self.loadStatus.emit("Logging in", 6)
        timer.Timeout = 30

        # Set temporary IP with IP config
        # Temp IP is same as controller IP from input
        configstr = "ifconfig eth0 " + conIP + "\n"
        self.writeCommand(serialObject, configstr, timer)

        if not prodMode:
            # Open new SSH client, auto-add key and login
            client2 = paramiko.SSHClient()
            client2.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client2.connect(conIP, username='root', password='Netsilicon')

            # Open SFTP client, copy previous network interface file back to PLC and close SSH connection
            sftp = client2.open_sftp()
            sftp.put(os.path.join(os.getcwd(), 'interfaces'), '/etc/network/interfaces')
            client2.close()

            # Update progress bar and reboot PLC
            self.loadStatus.emit("Applying network settings", 8)
            self.writeCommand(serialObject, 'reboot\n', timer)

            # Send tilde to interrupt boot sequence, boot controller and login to linux
            self.sendTilde(serialObject, timer)
            self.writeCommand(serialObject, boot, timer)
            self.loginCheck(serialObject, timer)

        # Update progress bar, close serial connection, end TFTP server and close progress bar
        self.loadStatus.emit("Finishing up", 9)
        serialObject.close()
        tftpObject.ServerKill()
        self.closeProg.emit()
        self.loadStatus.emit("Starting", 0)
        return True


# Class for TFTP server
# Takes string path of kernel files
class ServerClass(object):
    def __init__(self, ServerPath):
        self.ServerPath = ServerPath

        # Initialise server at kernel path
        self.server = tftpy.TftpServer(self.ServerPath)

    # Starts server
    def ServerFunc(self):
        self.server.listen()

    # Ends server
    def ServerKill(self):
        self.server.stop()

# Class for main window
class MainWindowUIClass(Ui_Dialog, QObject):

    def __init__(self):
        super().__init__()
        # Initialise child window classes
        self.progress = ProgressClass()
        self.popup = PopUpClass()
        self.aboutwindow = AboutClass()

    def setupUi(self, MW):
        super().setupUi(MW)

        # Connect buttons to functions

        # Clicking file select will run fileOpen
        self.fileSelect.clicked.connect(self.fileOpen)

        # Clicking load kernel will run generate
        self.goButton.clicked.connect(self.generate)

        # Opens about window
        self.about.clicked.connect(self.aboutwindow.opener)

        # Creates an event filter for the COMPort dropdown list
        # Used to repopulate list on click
        # Calls function eventFilter
        self.COMPort.installEventFilter(self)

        # Populates COM port list on start-up
        self.populateComPort()

    # Repopulates COMPort dropdown list when clicked
    def eventFilter(self, target, event):
        # If the COMPort gets clicked, run populate COMPort
        if target == self.COMPort and event.type() == QtCore.QEvent.MouseButtonPress:
            self.populateComPort()

        return False

    # Populates the COM port list
    def populateComPort(self):
        count = 0

        # Gets current attached COM ports, adds item in drop-down list for each port
        for comport in serial.tools.list_ports.comports():
            self.COMPort.clear()
            self.COMPort.addItem("")
            self.COMPort.setItemText(count, QtWidgets.QApplication.translate("Dialog", comport.device))
            count += 1

    # Opens file dialog window at current directory with "Open Linux kernel location" as window title and
    # sets pathEdit box to the selected directory
    def fileOpen(self):
        qfd = QFileDialog()
        filePath = QFileDialog.getExistingDirectory(qfd, str("Open Linux kernel location"), os.getcwd())
        self.pathEdit.setText(filePath)

    # Function which initialises and starts the update thread, and connects signals from update thread to GUI elements
    def generate(self):

        # Initialise UpdateThread with necessary variables pulled from GUI user input
        updaterThread = UpdateThread(self.COMPort.currentText(), self.conIP.text(), self.PCIP.text(),
                                     self.pathEdit.text(), self.prodMode.isChecked())

        # Connect PyQt signals to GUI elements
        # Example: when signal 'openProg' is sent by the updater thread, run progress.opener, opening the progress bar
        updaterThread.loadStatus.connect(self.progress.handle_change)
        updaterThread.openProg.connect(self.progress.opener)
        updaterThread.closeProg.connect(self.progress.closer)
        updaterThread.errorMessage.connect(self.popup.handle_error)
        updaterThread.loadPopup.connect(self.popup.opener)
        updaterThread.closePopup.connect(self.popup.closer)

        # Start the update thread
        updaterThread.start()

        # Open the progress bar and pop-up, then hide the pop-up immediately
        # This way it doesn't show on start-up, but is ready to be shown when necessary
        self.progress.exec_()
        self.popup.exec_()
        self.popup.hide()


# Sets up and opens main window
if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = MainWindowUIClass()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
